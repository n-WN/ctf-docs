<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式PWN入门指南</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Slate Gray & Amber -->
    <!-- Application Structure Plan: 本应用采用双栏布局。左侧是一个固定的、响应式的侧边栏导航，列出了报告中的所有核心概念。右侧是主内容区。这种设计的目的是提供一个清晰、持续的学习路径图，用户可以按顺序学习，也可以直接跳转到感兴趣的主题。点击侧边栏链接会通过JavaScript动态显示/隐藏主内容区对应的板块，从而在一个单页面内实现流畅的、无需刷新的内容切换。这种结构模仿了在线课程或文档站点的用户体验，非常适合这种结构化、教育性的内容，因为它将用户的注意力集中在当前的主题上，同时保持了整体内容的可见性和可访问性。 -->
    <!-- Visualization & Content Choices: 
        1. 进程内存布局: 目标=组织/通知 -> 方式=HTML/CSS交互式图表 -> 交互=鼠标悬停显示详细信息 -> 理由=比静态图片更具探索性，允许用户主动学习内存段的用途和权限 -> 库=无。
        2. 栈与函数调用 (动画): 目标=解释流程 -> 方式=HTML/CSS/JS分步动画，通过可视化容器明确区分栈帧 -> 交互=点击按钮触发栈帧、寄存器状态和代码行箭头同步变化 -> 理由=精确模拟x86-64调用约定，将抽象的函数调用过程具体化、可视化，建立栈与栈帧之间清晰的视觉联系。
        3. 编译与链接: 目标=教学/通知 -> 方式=HTML/CSS卡片式分步讲解 -> 交互=无 -> 理由=以情景化方式解释从源代码到可执行文件的完整流程，特别是阐明静态库与共享库(.so)的区别，为理解PLT/GOT奠定基础。
        4. 汇编语言：从零开始: 目标=教学/通知 -> 方式=HTML/CSS卡片式布局，故事化讲解 -> 交互=无 -> 理由=采用情景化教学法，详细拆解核心汇编指令，解释其在程序中的作用和对CPU状态的影响，为初学者建立坚实的汇编基础。
        5. 汇编基础术语: 目标=通知 -> 方式=HTML/CSS卡片式布局 -> 交互=无 -> 理由=以清晰、结构化的方式呈现核心汇编术语的定义和解释，便于查阅和学习。
        6. C到汇编探索: 目标=比较/通知 -> 方式=HTML/CSS/JS代码高亮和悬浮提示 -> 交互=鼠标悬停在C代码行上，汇编代码同步高亮；悬停在汇编代码的特定部分，弹出上下文相关的解释 -> 理由=建立高级语言和底层实现之间的直观、深度联系，解释每个汇编指令的精确作用。
        7. PLT & GOT 流程: 目标=解释流程 -> 方式=HTML/CSS分步点击流程图 -> 交互=点击“下一步”按钮高亮并显示流程中的当前步骤 -> 理由=将复杂的延迟绑定过程分解，逐步引导用户理解，比大段文字更有效 -> 库=无。
        8. ret2text实战演练: 目标=教学/演练 -> 方式=HTML/CSS/JS交互式双栈对比视图 -> 交互=点击按钮触发溢出，可视化展示返回地址被覆盖的过程 -> 理由=将ret2text的抽象理论通过具体的内存变化过程进行展示，加深对栈溢出核心原理的理解。
        9. 漏洞利用技术对比: 目标=比较 -> 方式=Chart.js雷达图和动态内容切换 -> 交互=点击按钮切换不同的技术，图表和文本描述会相应更新 -> 理由=雷达图能直观地展示多种技术在多个维度（要求、绕过、防御）上的优劣势，交互性使用户能聚焦于单个技术的分析 -> 库=Chart.js。
        10. ROP链构建: 目标=组织/通知 -> 方式=简化的点击式交互界面 -> 交互=用户点击“Gadgets”和“数据”来模拟在栈上构建ROP链的过程，并获得即时反馈 -> 理由=将抽象的ROP链概念具体化、游戏化，加深对栈布局和Gadget链接原理的理解 -> 库=无。
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .nav-link {
            transition: all 0.2s ease-in-out;
        }
        .nav-link.active {
            background-color: #f59e0b; /* amber-500 */
            color: #1f2937; /* gray-800 */
            font-weight: 700;
        }
        .nav-link:not(.active):hover {
            background-color: #4b5563; /* gray-600 */
        }
        .flowchart-step {
            transition: all 0.3s ease-in-out;
            opacity: 0.5;
            transform: scale(0.95);
        }
        .flowchart-step.active {
            opacity: 1;
            transform: scale(1);
            border-color: #f59e0b;
        }
        .tech-button.active {
            background-color: #f59e0b;
            color: #1f2937;
        }
        .code-inline {
            background-color: #374151; /* gray-700 */
            color: #fcd34d; /* amber-300 */
            padding: 2px 6px;
            border-radius: 4px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9em;
        }
        /* Stack Animation Styles */
        #code-arrow {
            transition: top 0.5s ease-in-out, opacity 0.5s ease-in-out;
        }
        .anim-code-line {
            transition: background-color 0.3s ease-in-out;
        }
        .anim-code-line.highlight {
            background-color: #f59e0b20;
        }
        .stack-frame {
             transition: all 0.5s ease-in-out;
             border: 2px solid;
             border-radius: 0.5rem;
             padding: 0.5rem;
             margin-top: 0.5rem;
        }
        .stack-frame-label {
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px dashed;
        }
        .stack-item, .reg-item, .demo-stack-item {
            transition: all 0.5s ease-in-out;
            opacity: 0;
            transform: translateY(10px);
        }
        .stack-item.visible, .reg-item.visible, .demo-stack-item.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .reg-value {
             transition: color 0.3s ease-in-out, background-color 0.3s ease-in-out;
        }
        .reg-value.highlight {
            color: #f59e0b; /* amber-400 */
            background-color: #f59e0b20;
        }
        .code-line.highlight {
            background-color: #f59e0b20; /* amber-500 with alpha */
            color: #f59e0b;
        }
        .asm-line.highlight {
            background-color: #3f3f46; /* gray-700 */
        }
        /* Assembly Tooltip */
        #asm-tooltip {
            position: absolute;
            display: none;
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 0.5rem;
            padding: 0.75rem;
            max-width: 300px;
            z-index: 100;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            pointer-events: none; /* Important */
        }
        #asm-tooltip-title {
            font-weight: bold;
            color: #f59e0b; /* amber-500 */
            margin-bottom: 0.5rem;
        }
        .asm-token {
            cursor: help;
            border-bottom: 1px dotted #6b7280; /* gray-500 */
        }
        .demo-stack-item.overwritten {
            background-color: #991b1b !important; /* red-800 */
            border-color: #f87171 !important; /* red-400 */
            color: #fee2e2; /* red-100 */
        }
    </style>
</head>
<body class="bg-gray-800 text-gray-200">
    <!-- Tooltip Element -->
    <div id="asm-tooltip">
        <div id="asm-tooltip-title"></div>
        <div id="asm-tooltip-desc"></div>
    </div>

    <div class="flex flex-col md:flex-row min-h-screen">
        <!-- Sidebar Navigation -->
        <aside id="sidebar" class="w-full md:w-64 bg-gray-900 text-white flex-shrink-0 p-4 transition-all duration-300">
            <h1 class="text-2xl font-bold text-amber-400 mb-6 border-b border-gray-700 pb-4">PWN入门指南</h1>
            <nav id="main-nav" class="space-y-2">
                <div>
                    <h2 class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">第一部分: 基础</h2>
                    <a href="#intro" data-section="intro" class="nav-link block p-3 rounded-lg">运行中程序的内部图景</a>
                    <a href="#compilation-linking" data-section="compilation-linking" class="nav-link block p-3 rounded-lg">从源代码到可执行文件</a>
                    <a href="#assembly-from-scratch" data-section="assembly-from-scratch" class="nav-link block p-3 rounded-lg">汇编语言：从零开始</a>
                    <a href="#stack-animation" data-section="stack-animation" class="nav-link block p-3 rounded-lg">栈与函数调用 (动画)</a>
                    <a href="#assembly-basics" data-section="assembly-basics" class="nav-link block p-3 rounded-lg">汇编基础术语</a>
                    <a href="#assembly-explorer" data-section="assembly-explorer" class="nav-link block p-3 rounded-lg">C 到汇编 (探索)</a>
                    <a href="#plt-got" data-section="plt-got" class="nav-link block p-3 rounded-lg">PLT 与 GOT</a>
                </div>
                <div>
                    <h2 class="text-xs font-bold text-gray-400 uppercase tracking-wider mt-4 mb-2">第二部分: 劫持控制流</h2>
                    <a href="#ret2text" data-section="ret2text" class="nav-link block p-3 rounded-lg">技术一: ret2text</a>
                    <a href="#ret2text-demo" data-section="ret2text-demo" class="nav-link block p-3 rounded-lg">ret2text: 实战演练</a>
                    <a href="#ret2shellcode" data-section="ret2shellcode" class="nav-link block p-3 rounded-lg">技术二: ret2shellcode</a>
                    <a href="#ret2libc" data-section="ret2libc" class="nav-link block p-3 rounded-lg">技术三: ret2libc & ROP</a>
                    <a href="#one-gadget" data-section="one-gadget" class="nav-link block p-3 rounded-lg">技术四: one-gadget</a>
                </div>
                 <div>
                    <h2 class="text-xs font-bold text-gray-400 uppercase tracking-wider mt-4 mb-2">综合对比</h2>
                    <a href="#comparison" data-section="comparison" class="nav-link block p-3 rounded-lg">技术对比分析</a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 p-4 sm:p-6 lg:p-8 bg-gray-800 overflow-y-auto">

            <!-- Section: Introduction & Memory Layout -->
            <section id="intro" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">运行中程序的内部图景</h2>
                <p class="text-lg text-gray-400 mb-8">任何二进制漏洞利用都建立在对程序正常运作方式的深刻理解之上。本节将通过一个交互式图表，剖析一个典型Linux进程的虚拟内存布局。您可以将鼠标悬停在不同的内存区域上，以了解它们的用途、权限和在漏洞利用中的作用。</p>
                
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <h3 class="text-2xl font-bold text-amber-400 mb-6 text-center">进程虚拟地址空间</h3>
                    <div class="relative w-full max-w-lg mx-auto h-96 flex flex-col justify-between text-center font-mono text-sm">
                        
                        <div class="memory-segment group border-2 border-dashed border-cyan-400 bg-cyan-900/30 p-4 rounded-lg">
                            <span class="font-bold text-cyan-300">栈 (Stack) ↓</span>
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-64 p-3 bg-gray-700 text-white rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
                                <strong>用途:</strong> 函数调用、局部变量、返回地址。<br>
                                <strong>权限:</strong> $rw-$<br>
                                <strong>增长方向:</strong> 向下（低地址）<br>
                                <strong>攻击相关:</strong> 栈溢出的主要攻击目标。
                            </div>
                        </div>

                        <div class="text-gray-500 my-2">... 内存空间 ...</div>

                        <div class="memory-segment group border-2 border-dashed border-purple-400 bg-purple-900/30 p-4 rounded-lg">
                             <span class="font-bold text-purple-300">堆 (Heap) ↑</span>
                             <div class="absolute top-full left-1/2 -translate-x-1/2 mt-2 w-64 p-3 bg-gray-700 text-white rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
                                <strong>用途:</strong> 动态内存分配 (<code class="code-inline">malloc</code>)。<br>
                                <strong>权限:</strong> $rw-$<br>
                                <strong>增长方向:</strong> 向上（高地址）<br>
                                <strong>攻击相关:</strong> 堆溢出、UAF等高级利用的目标。
                            </div>
                        </div>

                        <div class="memory-segment group border-2 border-dashed border-yellow-400 bg-yellow-900/30 p-4 rounded-lg mt-4">
                            <span class="font-bold text-yellow-300">.data / .bss</span>
                             <div class="absolute top-full left-1/2 -translate-x-1/2 mt-2 w-64 p-3 bg-gray-700 text-white rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
                                <strong>用途:</strong> 全局和静态变量。<br>
                                <strong>权限:</strong> $rw-$<br>
                                <strong>攻击相关:</strong> 可用于覆写全局变量，影响程序逻辑。
                            </div>
                        </div>

                        <div class="memory-segment group border-2 border-dashed border-red-400 bg-red-900/30 p-4 rounded-lg mt-4">
                            <span class="font-bold text-red-300">.text (代码段)</span>
                            <div class="absolute top-full left-1/2 -translate-x-1/2 mt-2 w-64 p-3 bg-gray-700 text-white rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10">
                                <strong>用途:</strong> 程序的可执行指令。<br>
                                <strong>权限:</strong> $r-x$<br>
                                <strong>攻击相关:</strong> ret2text的目标，ROP链的gadget来源。
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Section: Stack Animation -->
            <section id="stack-animation" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">栈与函数调用 (动画演示)</h2>
                <p class="text-lg text-gray-400 mb-8">栈是理解漏洞利用的关键。本节将通过动画精确演示一个x86-64函数调用是如何在底层操纵栈和寄存器的。点击“下一步”，观察<code class="code-inline">main</code>调用<code class="code-inline">add</code>函数时，参数传递、栈帧创建和返回的完整过程。</p>
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <div>
                            <h3 class="text-2xl font-bold text-amber-400 mb-4">代码示例</h3>
                            <div class="relative bg-gray-800 p-4 rounded-lg font-mono text-sm">
                                <div id="code-arrow" class="absolute left-[-10px] top-0 text-amber-400 text-xl opacity-0">→</div>
                                <pre><code id="stack-anim-code">
<div id="anim-code-line-1" class="anim-code-line p-1 rounded-sm">int add(int a, int b) {</div>
<div id="anim-code-line-2" class="anim-code-line p-1 rounded-sm">    int sum = a + b;</div>
<div id="anim-code-line-3" class="anim-code-line p-1 rounded-sm">    return sum;</div>
<div id="anim-code-line-4" class="anim-code-line p-1 rounded-sm">}</div>
<div class="h-4"></div>
<div id="anim-code-line-6" class="anim-code-line p-1 rounded-sm">void main() {</div>
<div id="anim-code-line-7" class="anim-code-line p-1 rounded-sm">    int result = 0;</div>
<div id="anim-code-line-8" class="anim-code-line p-1 rounded-sm">    result = add(5, 10);</div>
<div id="anim-code-line-9" class="anim-code-line p-1 rounded-sm">}</div>
                                </code></pre>
                            </div>
                             <div class="text-center mt-8">
                                <button id="stack-anim-prev-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg transition-colors">上一步</button>
                                <button id="stack-anim-next-btn" class="bg-amber-500 hover:bg-amber-600 text-gray-900 font-bold py-2 px-6 rounded-lg transition-colors ml-4">下一步</button>
                            </div>
                             <p id="stack-anim-desc" class="mt-4 text-center text-amber-300 h-16"></p>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                             <div>
                                <h3 class="text-2xl font-bold text-amber-400 mb-4 text-center">寄存器</h3>
                                <div id="register-visual-container" class="bg-gray-800 p-4 rounded-lg font-mono text-sm h-[450px] space-y-2">
                                     <!-- Registers will be added here -->
                                </div>
                            </div>
                            <div>
                                <h3 class="text-2xl font-bold text-amber-400 mb-4 text-center">栈</h3>
                                <div class="bg-gray-800 p-4 rounded-lg font-mono text-sm h-[450px] flex flex-col-reverse justify-start relative">
                                    <div class="text-xs text-gray-500 absolute top-2 right-2">高地址 ↑</div>
                                    <div id="stack-visual-container" class="space-y-1 w-full">
                                        <!-- Stack frames will be added here -->
                                    </div>
                                    <div class="text-xs text-gray-500 absolute bottom-2 right-2">低地址 ↓</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Section: Compilation and Linking -->
            <section id="compilation-linking" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">从源代码到可执行文件</h2>
                <p class="text-lg text-gray-400 mb-8">我们写的C代码是如何变成一个可以运行的程序的？理解这个过程——编译、汇编、链接——是理解PLT/GOT和共享库（<code class="code-inline">.so</code>文件）的前提。让我们跟随一个简单的 <code class="code-inline">hello.c</code> 文件，走完它的整个生命周期。</p>

                <div class="space-y-8">
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4 flex items-center"><span class="text-3xl mr-4">①</span> 预处理 (Preprocessing)</h3>
                        <p class="mb-4 text-gray-300">旅程的第一步。预处理器像一个秘书，它处理所有以 <code class="code-inline">#</code> 开头的指令。最常见的任务是：</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                            <li><code class="code-inline">#include &lt;stdio.h&gt;</code>: 将头文件的内容直接“粘贴”到你的代码中。</li>
                            <li><code class="code-inline">#define PI 3.14</code>: 进行简单的文本替换。</li>
                        </ul>
                        <p class="mt-4 text-gray-300">这个阶段的输出仍然是人类可读的C代码，只是内容更完整了。</p>
                        <div class="text-center mt-4 font-mono text-amber-300">hello.c → (gcc -E) → hello.i</div>
                    </div>

                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4 flex items-center"><span class="text-3xl mr-4">②</span> 编译 (Compilation)</h3>
                        <p class="mb-4 text-gray-300">这是核心的翻译工作。编译器（如GCC）接收预处理后的C代码，并将其翻译成对应平台的汇编语言。这是我们从高级语言到低级语言的第一步。</p>
                        <p class="mt-4 text-gray-300">这个阶段的输出是汇编代码文件，通常以 <code class="code-inline">.s</code> 或 <code class="code-inline">.asm</code> 结尾。</p>
                        <div class="text-center mt-4 font-mono text-amber-300">hello.i → (gcc -S) → hello.s</div>
                    </div>
                    
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4 flex items-center"><span class="text-3xl mr-4">③</span> 汇编 (Assembly)</h3>
                        <p class="mb-4 text-gray-300">汇编器（Assembler）接管汇编代码，并将其翻译成CPU能直接理解的机器码。但是，这些机器码还不能直接运行。</p>
                        <p class="mt-4 text-gray-300">输出是一个“目标文件”（Object File），通常以 <code class="code-inline">.o</code> 结尾。它包含了程序的机器码、数据，以及一张“符号表”。这张表记录了像 <code class="code-inline">main</code> 这样的函数名，但对于外部函数如 <code class="code-inline">printf</code>，它只有一个标记，表示“我需要这个函数，但不知道它在哪”。</p>
                        <div class="text-center mt-4 font-mono text-amber-300">hello.s → (gcc -c) → hello.o</div>
                    </div>
                    
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4 flex items-center"><span class="text-3xl mr-4">④</span> 链接 (Linking)</h3>
                        <p class="mb-4 text-gray-300">这是最后一步，也是最关键的一步。链接器（Linker, <code class="code-inline">ld</code>）的工作是把多个目标文件（<code class="code-inline">.o</code>）和库文件粘合在一起，解决所有悬而未决的地址引用，最终生成一个可执行文件。这里有两种主要的链接方式。</p>
                        
                        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div class="bg-gray-800 p-4 rounded-lg border-l-4 border-cyan-400">
                                <h4 class="text-xl font-bold text-cyan-300 mb-2">静态链接 (Static Linking)</h4>
                                <p class="text-gray-400"><strong>方式:</strong> 链接器会找到所有需要的函数（比如 <code class="code-inline">printf</code>），然后把它们的机器码从静态库（<code class="code-inline">.a</code> 文件）中完整地复制到最终的可执行文件中。</p>
                                <p class="text-gray-400 mt-2"><strong>结果:</strong> 一个庞大但自给自足的可执行文件。它不依赖任何外部库文件就能运行。</p>
                                <p class="text-gray-400 mt-2"><strong>优点:</strong> 部署简单，没有依赖问题。</p>
                                <p class="text-gray-400 mt-2"><strong>缺点:</strong> 文件体积大，多个程序会包含同一份库代码，造成冗余；库更新后，所有程序都必须重新编译。</p>
                            </div>
                            <div class="bg-gray-800 p-4 rounded-lg border-l-4 border-purple-400">
                                <h4 class="text-xl font-bold text-purple-300 mb-2">动态链接 (Dynamic Linking)</h4>
                                <p class="text-gray-400"><strong>方式:</strong> 链接器在处理对 <code class="code-inline">printf</code> 的调用时，并**不**复制它的代码。相反，它做两件事：</p>
                                <ol class="list-decimal list-inside text-gray-400 ml-4 mt-2">
                                    <li>在可执行文件中留下一个小小的“存根”（stub），这就是PLT的作用。</li>
                                    <li>记录下一个依赖项：“这个程序需要 <code class="code-inline">libc.so.6</code>”。</li>
                                </ol>
                                <p class="text-gray-400 mt-2"><strong>结果:</strong> 一个体积小巧的可执行文件。当它运行时，操作系统会看到这个依赖项，并由动态链接器（<code class="code-inline">/lib/ld-linux.so.2</code>）在内存中加载 <code class="code-inline">libc.so.6</code>，然后才真正把二者联系起来。这就是GOT表被填充的时刻。</p>
                                 <p class="text-gray-400 mt-2"><strong><code class="code-inline">.so</code>文件 (Shared Object)</strong> 就是为这种方式而生的、可被多个程序在运行时共享的库文件。这正是我们<code class="code-inline">ret2libc</code>攻击的目标。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section: Assembly From Scratch -->
            <section id="assembly-from-scratch" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">汇编语言：从零开始</h2>
                <p class="text-lg text-gray-400 mb-8">要真正“Pwn”一个程序，你必须学会说它的语言——汇编。这不是要你手写汇编，而是要能读懂它。本章将通过情景化的方式，带你理解CPU是如何通过汇编指令来执行我们编写的C代码的。</p>

                <div class="space-y-8">
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">第一幕：CPU的“草稿纸”——寄存器</h3>
                        <p class="mb-6 text-gray-300">想象一下CPU正在做计算，它需要一些临时的地方来存放数字和地址。这些地方就是寄存器，它们是CPU内部最快、最核心的存储单元。对于Pwner来说，最重要的几个“角色”是：</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li><code class="code-inline">RIP</code> (指令指针): 永远指向下一条要执行的指令。**控制它，就控制了一切。**</li>
                            <li><code class="code-inline">RSP</code> (栈指针): 永远指向栈的顶部。它像一个永远在动的浮标。</li>
                            <li><code class="code-inline">RBP</code> (基址指针): 像一个锚点，固定在当前函数栈帧的底部，方便我们找到局部变量。</li>
                            <li><code class="code-inline">RAX</code>: 默认的“快递员”，负责携带函数的返回值。</li>
                            <li><code class="code-inline">RDI</code>, <code class="code-inline">RSI</code>, <code class="code-inline">RDX</code>... : 另外几位“快递员”，负责传递函数的前几个参数。</li>
                        </ul>
                    </div>

                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">第二幕：数据的流动——<code class="code-inline">mov</code>指令</h3>
                        <p class="mb-6 text-gray-300">程序世界里绝大部分时间都在做一件事：搬运数据。而<code class="code-inline">mov</code>指令就是搬运工。它的语法是 <code class="code-inline">mov 目的地, 源</code>。</p>
                        <div class="bg-gray-800 p-4 rounded-lg font-mono text-sm space-y-2">
                           <p><code class="code-inline">mov rax, rbx</code>  ; 把rbx寄存器的内容，复制到rax寄存器。</p>
                           <p><code class="code-inline">mov rax, 10</code>   ; 把数字10，直接放入rax寄存器。</p>
                           <p><code class="code-inline">mov rax, [rbp-0x8]</code> ; 注意方括号！这不是把`rbp-0x8`这个数值给rax，而是把`rbp-0x8`这个**地址里的内容**取出来，给rax。这是从内存读取。</p>
                           <p><code class="code-inline">mov [rbp-0x8], rax</code> ; 把rax寄存器的内容，存到`rbp-0x8`这个**地址指向的内存里**。这是写入内存。</p>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">第三幕：改变世界——算术与逻辑指令</h3>
                        <p class="mb-6 text-gray-300">数据搬运就位后，就要开始计算了。</p>
                         <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li><code class="code-inline">add rax, rbx</code>: 执行 `rax = rax + rbx`。</li>
                            <li><code class="code-inline">sub rax, 10</code>: 执行 `rax = rax - 10`。</li>
                            <li><code class="code-inline">inc rax</code>: `rax++`，将rax的值加1。</li>
                            <li><code class="code-inline">xor rax, rax</code>: `rax = rax ^ rax`，这是一个将rax清零的常用技巧，因为它比<code class="code-inline">mov rax, 0</code>指令更短。</li>
                        </ul>
                    </div>

                     <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">第四幕：程序的逻辑——比较与跳转</h3>
                        <p class="mb-6 text-gray-300">程序如何实现<code class="code-inline">if-else</code>？答案是两步：比较和跳转。</p>
                        <ol class="list-decimal list-inside space-y-2 text-gray-300">
                            <li><strong>比较 (<code class="code-inline">cmp</code>)</strong>: <code class="code-inline">cmp rax, rbx</code> 指令会计算`rax - rbx`，但不保存结果。它只根据结果（是正、是负、还是零）来设置CPU内部的一些“标志位”(Flags)。</li>
                            <li><strong>条件跳转</strong>: 紧跟在<code class="code-inline">cmp</code>后面的跳转指令会检查这些标志位，并决定是否要跳转。
                                <ul class="list-disc list-inside space-y-2 text-gray-400 mt-2 ml-6">
                                    <li><code class="code-inline">je</code> (Jump if Equal): 如果上次比较结果为零（即相等），就跳转。</li>
                                    <li><code class="code-inline">jne</code> (Jump if Not Equal): 如果不相等，就跳转。</li>
                                    <li><code class="code-inline">jg</code> (Jump if Greater): 如果大于，就跳转。</li>
                                    <li><code class="code-inline">jl</code> (Jump if Less): 如果小于，就跳转。</li>
                                </ul>
                            </li>
                            <li><strong>无条件跳转 (<code class="code-inline">jmp</code>)</strong>: 不管三七二十一，直接跳转到指定地址。</li>
                        </ol>
                    </div>

                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">终幕：函数调用的舞蹈——<code class="code-inline">call</code>与<code class="code-inline">ret</code></h3>
                        <p class="mb-6 text-gray-300">这是所有栈溢出攻击的核心舞台。函数调用和返回是一对精确配合的舞蹈动作，一旦被打乱，程序就会失控。</p>
                         <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li><strong><code class="code-inline">call function_address</code></strong>: 这个指令做了两件事：
                                <ol class="list-decimal list-inside text-gray-400 mt-2 ml-6">
                                    <li>**保存“回家”的路**: 把<code class="code-inline">call</code>指令的**下一条指令**的地址（也就是返回地址）压到栈顶。</li>
                                    <li>**出发**: 无条件跳转到<code class="code-inline">function_address</code>开始执行。</li>
                                </ol>
                            </li>
                            <li class="mt-4"><strong><code class="code-inline">ret</code></strong>: 这个指令只做一件事：
                                <ol class="list-decimal list-inside text-gray-400 mt-2 ml-6">
                                     <li>**回家</strong>: 从栈顶弹出一个值，并无条件跳转到这个值所代表的地址。</li>
                                </ol>
                            </li>
                        </ul>
                        <p class="mt-6 text-amber-300">看出来了吗？<code class="code-inline">call</code>把返回地址存放在栈上，而<code class="code-inline">ret</code>盲目地相信栈上的这个地址。如果我们能通过缓冲区溢出覆写这个地址，那么当函数执行到<code class="code-inline">ret</code>时，它就会乖乖地跳转到我们指定的任何地方。**这就是漏洞利用的本质。**</p>
                    </div>
                </div>
            </section>
            
            <!-- Section: Assembly Basics -->
            <section id="assembly-basics" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">汇编基础术语</h2>
                <p class="text-lg text-gray-400 mb-8">理解底层代码如何操作数据和内存是PWN的基础。本节将解释一些在汇编代码中最常见、也最重要的术语和概念。</p>

                <div class="space-y-8">
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">数据类型指示符 (Size Directives)</h3>
                        <p class="mb-6 text-gray-300">汇编指令需要知道操作数据的大小。这些指示符明确了内存操作的字节数。</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>DWORD:</strong> "双字", 32位 (4字节). 对应 C 中的 <code class="code-inline">int</code>.</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>QWORD:</strong> "四字", 64位 (8字节). 对应 C 中的指针或 <code class="code-inline">long long</code>.</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>WORD:</strong> "字", 16位 (2字节). 对应 C 中的 <code class="code-inline">short</code>.</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>BYTE:</strong> "字节", 8位 (1字节). 对应 C 中的 <code class="code-inline">char</code>.</div>
                        </div>
                    </div>

                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">内存操作指示符</h3>
                        <div class="bg-gray-800 p-4 rounded-lg">
                            <p class="text-lg mb-2"><strong>PTR (Pointer)</strong></p>
                            <p class="text-gray-300">PTR告诉汇编器，方括号 <code class="code-inline">[]</code> 里的内容是一个内存地址，而不是一个数字。它总是和大小指示符（如<code class="code-inline">DWORD</code>）一起使用，形成 <code class="code-inline">DWORD PTR</code> 这样的组合，意为“请将[...]地址处的内存看作一个32位的值”。</p>
                        </div>
                    </div>
                    
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">关键寄存器 (Registers)</h3>
                         <p class="mb-6 text-gray-300">寄存器是CPU内部的高速存储单元，是计算和数据操作的“工作台”。</p>
                        <div class="space-y-4">
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>RBP (Base Pointer):</strong> 通常指向当前函数栈帧的“底部”，作为访问局部变量和参数的稳定基准点。</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>RSP (Stack Pointer):</strong> 始终指向栈的“顶部”（最低地址处）。<code class="code-inline">push</code>和<code class="code-inline">pop</code>操作会直接修改RSP。</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>RIP (Instruction Pointer):</strong> 存放下一条将要被CPU执行的指令的地址。控制RIP是所有控制流劫持攻击的最终目标。</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>RAX:</strong> 通常用于存放函数返回值。</div>
                            <div class="bg-gray-800 p-4 rounded-lg"><strong>RDI, RSI, RDX, RCX...:</strong> 用于传递函数的前几个参数（在x86-64 Linux中）。控制这些寄存器是ROP攻击的关键。</div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                        <h3 class="text-2xl font-bold text-amber-400 mb-4">综合示例分析</h3>
                        <p class="mb-4 text-gray-300">让我们重新审视一下这行代码，将所有概念联系起来：</p>
                        <div class="bg-gray-800 p-4 rounded-lg text-center text-lg">
                            <code class="code-inline">mov DWORD PTR [rbp-0x14], edi</code>
                        </div>
                        <p class="mt-4 text-gray-300">
                           这句话的完整含义是：“将传入的第一个32位参数（存放在<code class="code-inline">edi</code>寄存器中），复制（<code class="code-inline">mov</code>）到当前函数栈帧里、距离栈底<code class="code-inline">rbp</code>偏移<code class="code-inline">0x14</code>的那个4字节（<code class="code-inline">DWORD PTR</code>）内存位置。”
                        </p>
                    </div>
                </div>
            </section>

             <!-- Section: Assembly Explorer -->
            <section id="assembly-explorer" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">C 到汇编 (交互探索)</h2>
                <p class="text-lg text-gray-400 mb-8">我们编写的C代码最终都会被编译器翻译成机器能够理解的汇编指令。理解这种对应关系是进行底层分析的基础。将鼠标悬停在左侧的C代码行上，右侧对应的汇编指令将会高亮显示。您也可以悬停在汇编代码的每个部分上，查看其详细解释。</p>
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 font-mono text-sm">
                        <div>
                            <h3 class="text-2xl font-bold text-amber-400 mb-4">C 代码</h3>
                            <pre class="bg-gray-800 p-4 rounded-lg"><code id="c-code-container" class="whitespace-pre-wrap leading-normal">
<div class="code-line p-1 rounded" data-line="1">int simple_add(int a, int b) {</div>
<div class="code-line p-1 rounded" data-line="2">    int sum = a + b;</div>
<div class="code-line p-1 rounded" data-line="3">    return sum;</div>
<div class="code-line p-1 rounded" data-line="4">}</div>
                            </code></pre>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-amber-400 mb-4">x86-64 汇编 (GCC -O0)</h3>
                             <pre class="bg-gray-800 p-4 rounded-lg"><code id="asm-code-container" class="whitespace-pre-wrap leading-normal">
<div class="asm-line" data-line="1">simple_add:</div>
<div class="asm-line" data-line="1">  <span class="asm-token" data-key="push">push</span>   <span class="asm-token" data-key="rbp">rbp</span></div>
<div class="asm-line" data-line="1">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="rbp">rbp</span>, <span class="asm-token" data-key="rsp">rsp</span></div>
<div class="asm-line" data-line="1">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-14">[rbp-0x14]</span>, <span class="asm-token" data-key="edi">edi</span></div>
<div class="asm-line" data-line="1">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-18">[rbp-0x18]</span>, <span class="asm-token" data-key="esi">esi</span></div>
<div class="asm-line" data-line="2">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="edx">edx</span>, <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-14">[rbp-0x14]</span></div>
<div class="asm-line" data-line="2">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="eax">eax</span>, <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-18">[rbp-0x18]</span></div>
<div class="asm-line" data-line="2">  <span class="asm-token" data-key="add">add</span>    <span class="asm-token" data-key="eax">eax</span>, <span class="asm-token" data-key="edx">edx</span></div>
<div class="asm-line" data-line="2">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-4">[rbp-0x4]</span>, <span class="asm-token" data-key="eax">eax</span></div>
<div class="asm-line" data-line="3">  <span class="asm-token" data-key="mov">mov</span>    <span class="asm-token" data-key="eax">eax</span>, <span class="asm-token" data-key="dword_ptr">DWORD PTR</span> <span class="asm-token" data-key="rbp-4">[rbp-0x4]</span></div>
<div class="asm-line" data-line="4">  <span class="asm-token" data-key="pop">pop</span>    <span class="asm-token" data-key="rbp">rbp</span></div>
<div class="asm-line" data-line="4">  <span class="asm-token" data-key="ret">ret</span></div>
                            </code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section: PLT & GOT -->
            <section id="plt-got" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">PLT 与 GOT：动态链接的桥梁</h2>
                <p class="text-lg text-gray-400 mb-8">程序如何调用共享库（如<code class="code-inline">libc</code>）中的函数？答案在于PLT和GOT的精妙协作。这是一个“延迟绑定”的过程，即函数地址只在第一次被调用时才解析。下方的交互式流程图将分步展示这个过程。请点击“下一步”来观察函数（以<code class="code-inline">puts</code>为例）首次被调用时的完整流程。</p>
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <div id="flowchart-container" class="grid grid-cols-1 md:grid-cols-3 gap-6 items-center text-center">
                        <div id="flow-step-1" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                            <div class="text-amber-400 text-5xl mb-2">①</div>
                            <h3 class="text-xl font-bold mb-2">程序代码</h3>
                            <p><code class="code-inline">call puts@plt</code></p>
                            <p class="text-sm text-gray-400">执行流跳转到PLT中的<code class="code-inline">puts</code>存根。</p>
                        </div>
                        <div id="flow-step-2" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                            <div class="text-amber-400 text-5xl mb-2">②</div>
                            <h3 class="text-xl font-bold mb-2">PLT 存根</h3>
                            <p><code class="code-inline">jmp [puts@got.plt]</code></p>
                            <p class="text-sm text-gray-400">跳转到GOT表项中存储的地址。</p>
                        </div>
                        <div id="flow-step-3" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                           <div class="text-amber-400 text-5xl mb-2">③</div>
                            <h3 class="text-xl font-bold mb-2">GOT 表项 (首次)</h3>
                            <p>指向 PLT 存根的下一条指令</p>
                            <p class="text-sm text-gray-400">地址被预设，将控制权交还给PLT。</p>
                        </div>
                        <div id="flow-step-4" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                           <div class="text-amber-400 text-5xl mb-2">④</div>
                            <h3 class="text-xl font-bold mb-2">PLT (续)</h3>
                            <p><code class="code-inline">push id; jmp resolver</code></p>
                            <p class="text-sm text-gray-400">准备参数并跳转到动态链接器。</p>
                        </div>
                        <div id="flow-step-5" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                            <div class="text-amber-400 text-5xl mb-2">⑤</div>
                            <h3 class="text-xl font-bold mb-2">链接器解析</h3>
                            <p><code class="code-inline">_dl_runtime_resolve()</code></p>
                            <p class="text-sm text-gray-400">查找<code class="code-inline">puts</code>真实地址，并用它覆写GOT表项。</p>
                        </div>
                         <div id="flow-step-6" class="flowchart-step bg-gray-800 p-6 rounded-lg border-2 border-transparent">
                            <div class="text-amber-400 text-5xl mb-2">⑥</div>
                            <h3 class="text-xl font-bold mb-2">GOT 表项 (更新后)</h3>
                            <p>指向 libc 中的 <code class="code-inline">puts</code> 函数</p>
                            <p class="text-sm text-gray-400">绑定完成！后续调用将直接跳转到libc。</p>
                        </div>
                    </div>
                    <div class="text-center mt-8">
                        <button id="flowchart-next-btn" class="bg-amber-500 hover:bg-amber-600 text-gray-900 font-bold py-2 px-6 rounded-lg transition-colors">开始/下一步</button>
                        <button id="flowchart-reset-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg transition-colors ml-4">重置</button>
                    </div>
                </div>
            </section>
            
            <section id="ret2text" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">技术一: ret2text (返回到代码段)</h2>
                <p class="text-lg text-gray-400 mb-6">这是最直接的漏洞利用技术。当程序存在一个栈溢出漏洞时，我们可以覆写返回地址，使其指向程序自身<code class="code-inline">.text</code>段中已经存在的某个函数，例如一个开发者留下的“后门”函数 (<code class="code-inline">win()</code>)。这种方法的优点是简单直接，并且能天然绕过NX保护，因为代码段本身就是可执行的。</p>
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <h3 class="text-2xl font-bold text-amber-400 mb-4">攻击载荷结构</h3>
                    <div class="font-mono text-center bg-gray-800 p-4 rounded-lg">
                        <span class="text-red-400"> [ 填 充 数 据 ] </span>
                        <span class="text-gray-500">+</span>
                        <span class="text-green-400"> [ win() 函数的地址 ] </span>
                    </div>
                    <h3 class="text-2xl font-bold text-amber-400 mt-8 mb-4">核心思想</h3>
                    <p>利用栈溢出，将<code class="code-inline">ret</code>指令要跳转的地址，从原始的调用者地址，精准地替换为我们想要执行的、程序中已有的另一个函数的地址。这就像是篡改了火车时刻表上的下一站地址，让火车开往一个意想不到的目的地。</p>
                </div>
            </section>

            <!-- Section: ret2text Demo -->
            <section id="ret2text-demo" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">ret2text: 实战演练</h2>
                <p class="text-lg text-gray-400 mb-8">理论结合实践是最好的学习方式。本节将通过一个交互式演练，让您亲眼目睹一个<code class="code-inline">ret2text</code>攻击是如何在内存层面发生的。我们将利用一个包含<code class="code-inline">gets()</code>函数的漏洞来覆写返回地址，并跳转到<code class="code-inline">win()</code>函数。</p>
                
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <div>
                            <h3 class="text-2xl font-bold text-amber-400 mb-4">目标代码</h3>
                            <pre class="bg-gray-800 p-4 rounded-lg font-mono text-sm">
void win() {
    puts("Code execution hijacked!");
}

void vulnerable() {
    char buffer[64];
    puts("Enter your name:");
    gets(buffer);
}

void main() {
    vulnerable();
}
                            </pre>
                            <h3 class="text-2xl font-bold text-amber-400 mt-8 mb-4">攻击载荷 (Payload)</h3>
                             <p class="text-gray-300 mb-4">我们需要构造一个输入，它由三部分组成：填满缓冲区的垃圾数据、覆写保存的RBP的8个字节、以及我们想要跳转到的<code class="code-inline">win()</code>函数的地址。</p>
                            <pre class="bg-gray-800 p-4 rounded-lg font-mono text-sm text-center">
'A' * 64 + 'B' * 8 + 0x401186
                            </pre>
                            <div class="text-center mt-8">
                               <button id="ret2text-execute-btn" class="bg-amber-500 hover:bg-amber-600 text-gray-900 font-bold py-3 px-8 rounded-lg transition-colors text-lg">执行溢出</button>
                           </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <h3 class="text-xl font-bold text-center mb-2">溢出前的栈</h3>
                                <div id="stack-before-overflow" class="bg-gray-800 p-4 rounded-lg font-mono text-sm h-[400px] flex flex-col-reverse justify-start relative"></div>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold text-center mb-2">溢出后的栈</h3>
                                <div id="stack-after-overflow" class="bg-gray-800 p-4 rounded-lg font-mono text-sm h-[400px] flex flex-col-reverse justify-start relative"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="ret2shellcode" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">技术二: ret2shellcode (返回到Shellcode)</h2>
                <p class="text-lg text-gray-400 mb-6">如果程序中没有方便的“后门”函数可供调用，我们可以尝试自己注入一小段机器码（称为<code class="code-inline">shellcode</code>），然后劫持控制流去执行它。通常，我们会把<code class="code-inline">shellcode</code>放置在栈上，并通过溢出将返回地址指向这段<code class="code-inline">shellcode</code>的起始位置。这种技术威力强大，能实现任意代码执行。</p>
                 <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <h3 class="text-2xl font-bold text-amber-400 mb-4">攻击载荷结构</h3>
                    <div class="font-mono text-center bg-gray-800 p-4 rounded-lg flex flex-wrap justify-center items-center gap-2">
                        <span class="text-red-400">[填充]</span>
                        <span class="text-gray-500">+</span>
                        <span class="text-green-400">[Shellcode地址]</span>
                        <span class="text-gray-500">+</span>
                        <span class="text-cyan-400">[NOP雪橇]</span>
                        <span class="text-gray-500">+</span>
                        <span class="text-purple-400">[Shellcode]</span>
                    </div>
                    <h3 class="text-2xl font-bold text-amber-400 mt-8 mb-4">主要挑战</h3>
                    <ul class="list-disc list-inside space-y-2 text-gray-300">
                        <li><strong>NX (数据执行保护):</strong> 这是最主要的障碍。现代系统通常会禁止在栈上执行代码。如果NX开启，此技术直接失效。</li>
                        <li><strong>ASLR (地址空间布局随机化):</strong> 栈的地址是随机的，我们无法硬编码一个精确的<code class="code-inline">shellcode</code>地址。需要配合信息泄漏来定位。</li>
                        <li><strong>坏字符:</strong> 像<code class="code-inline">\x00</code> (空字节) 这样的字符可能会截断我们的输入，导致<code class="code-inline">shellcode</code>注入不完整。</li>
                    </ul>
                </div>
            </section>
            
            <section id="ret2libc" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">技术三: ret2libc & ROP</h2>
                <p class="text-lg text-gray-400 mb-6">为了绕过NX保护，我们不再注入自己的代码，而是重用（return to）已加载的共享库（<code class="code-inline">libc</code>）中的代码。例如，我们可以调用<code class="code-inline">libc</code>中的<code class="code-inline">system()</code>函数来获取shell。但如何向<code class="code-inline">system()</code>传递参数（如<code class="code-inline">"/bin/sh"</code>）呢？这就引出了返回导向编程（ROP）的概念。我们通过寻找代码中以<code class="code-inline">ret</code>结尾的小片段（gadgets），精心构造一个“ROP链”，像搭积木一样，先调用<code class="code-inline">pop rdi; ret</code>这样的gadget来设置参数，最后再调用<code class="code-inline">system</code>函数。</p>
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <h3 class="text-2xl font-bold text-amber-400 mb-4">ROP链模拟器: 调用 <code class="code-inline">system("/bin/sh")</code></h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h4 class="text-xl font-bold mb-4">可用资源</h4>
                            <div class="space-y-3">
                                <button data-rop="pop rdi" class="rop-item w-full text-left bg-gray-700 hover:bg-gray-600 p-3 rounded-lg transition-colors">Gadget: <code class="code-inline">pop rdi; ret</code></button>
                                <button data-rop="system" class="rop-item w-full text-left bg-gray-700 hover:bg-gray-600 p-3 rounded-lg transition-colors">函数: <code class="code-inline">system()</code></button>
                                <button data-rop="/bin/sh" class="rop-item w-full text-left bg-gray-700 hover:bg-gray-600 p-3 rounded-lg transition-colors">数据: <code class="code-inline">"/bin/sh"</code> 地址</button>
                            </div>
                             <button id="rop-reset-btn" class="w-full mt-4 bg-red-600 hover:bg-red-700 text-white font-bold p-3 rounded-lg transition-colors">重置ROP链</button>
                        </div>
                        <div>
                            <h4 class="text-xl font-bold mb-4">栈布局 (从低地址到高地址)</h4>
                            <div id="rop-stack" class="bg-gray-800 p-4 rounded-lg min-h-[200px] font-mono flex flex-col-reverse">
                            </div>
                        </div>
                    </div>
                    <div id="rop-feedback" class="mt-4 text-center h-6 font-bold"></div>
                </div>
            </section>

            <section id="one-gadget" class="content-section">
                 <h2 class="text-4xl font-bold text-white mb-4">技术四: one-gadget</h2>
                <p class="text-lg text-gray-400 mb-6"><code class="code-inline">one-gadget</code>是ROP的一种优雅的快捷方式。在<code class="code-inline">libc</code>中，存在一些“神奇”的地址，只要直接跳转到那里，在满足某些寄存器状态（如<code class="code-inline">rsi == NULL</code>）的前提下，就能直接获得一个shell。这种方法省去了手动构建ROP链的麻烦，但其成功与否依赖于是否能满足它的前置约束条件。</p>
                 <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                    <h3 class="text-2xl font-bold text-amber-400 mb-4">核心思想</h3>
                    <p class="mb-4">寻找并利用<code class="code-inline">libc</code>中“一步到位”的gadget。这就像是在游戏中找到了一个可以直接通关的秘密传送门，但前提是你必须持有正确的“钥匙”（满足寄存器约束）。</p>
                    <div class="bg-gray-800 p-4 rounded-lg font-mono">
                        <p class="text-green-400"># 运行 one_gadget 工具</p>
                        <p>$ one_gadget /lib/x86_64-linux-gnu/libc.so.6</p>
                        <p class="mt-2 text-gray-400">0x4f322 execve("/bin/sh", rsp+0x40, environ) <span class="text-red-400">constraints: [rsp+0x40] == NULL</span></p>
                        <p class="text-gray-400">0x10a41c execve("/bin/sh", rsp+0x70, environ) <span class="text-red-400">constraints: [rsp+0x70] == NULL</span></p>
                    </div>
                    <p class="mt-4">漏洞利用者的任务就是：泄漏<code class="code-inline">libc</code>基地址，然后检查在程序返回的时刻，是否有某个<code class="code-inline">one-gadget</code>的约束条件恰好被满足。如果满足，只需一次跳转即可成功；如果不满足，则还是需要退回到传统的ROP方法。</p>
                </div>
            </section>
            
            <section id="comparison" class="content-section">
                <h2 class="text-4xl font-bold text-white mb-4">漏洞利用技术对比分析</h2>
                <p class="text-lg text-gray-400 mb-8">不同的漏洞利用技术各有其优缺点、前提条件和适用场景。下方是一个交互式的对比图。您可以点击按钮来切换不同的技术，雷达图和下方的描述将会动态更新，以展示该技术在“实现难度”、“威力”、“要求”和“绕过能力”等多个维度上的特点。</p>
                
                <div class="bg-gray-900 p-6 rounded-xl shadow-2xl">
                     <div class="flex justify-center flex-wrap gap-2 mb-8">
                        <button class="tech-button py-2 px-4 bg-gray-700 rounded-lg transition-colors" data-tech="ret2text">ret2text</button>
                        <button class="tech-button py-2 px-4 bg-gray-700 rounded-lg transition-colors" data-tech="ret2shellcode">ret2shellcode</button>
                        <button class="tech-button py-2 px-4 bg-gray-700 rounded-lg transition-colors" data-tech="ret2libc">ret2libc/ROP</button>
                        <button class="tech-button py-2 px-4 bg-gray-700 rounded-lg transition-colors" data-tech="one-gadget">one-gadget</button>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                        <div>
                            <h3 id="tech-title" class="text-2xl font-bold text-amber-400 mb-4"></h3>
                            <p id="tech-description" class="text-gray-300"></p>
                            <div class="mt-4">
                                <p><strong><span class="text-green-400">绕过:</span></strong> <span id="tech-bypass"></span></p>
                                <p><strong><span class="text-red-400">被防御:</span></strong> <span id="tech-blocked"></span></p>
                            </div>
                        </div>
                         <div class="chart-container w-full max-w-md mx-auto h-80 md:h-96">
                            <canvas id="tech-radar-chart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('.content-section');

            function showSection(hash) {
                const targetHash = hash || '#intro';
                const targetSectionId = targetHash.substring(1);
                sections.forEach(section => section.classList.toggle('active', section.id === targetSectionId));
                navLinks.forEach(link => link.classList.toggle('active', link.getAttribute('href') === targetHash));
            }
            
            document.getElementById('main-nav').addEventListener('click', function(e) {
                if(e.target.matches('.nav-link')) {
                    e.preventDefault();
                    const targetHash = e.target.getAttribute('href');
                    if(window.location.hash !== targetHash) history.pushState(null, null, targetHash);
                    showSection(targetHash);
                }
            });
            
            window.addEventListener('popstate', () => showSection(window.location.hash));
            showSection(window.location.hash || '#intro');

            // Stack Animation Logic
            const stackAnim = {
                stackContainer: document.getElementById('stack-visual-container'),
                regContainer: document.getElementById('register-visual-container'),
                desc: document.getElementById('stack-anim-desc'),
                prevBtn: document.getElementById('stack-anim-prev-btn'),
                nextBtn: document.getElementById('stack-anim-next-btn'),
                arrow: document.getElementById('code-arrow'),
                codeLines: document.querySelectorAll('.anim-code-line'),
                currentStep: 0,
                steps: [
                    { desc: "进入main函数，为其局部变量result创建栈帧。", 
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }] }],
                      regs: { RDI: '?', RSI: '?', RAX: '?', RSP: '0x7ff...c8', RBP: '0x7ff...d0'}, codeLine: 7 },
                    { desc: "准备调用add(5, 10)。参数被加载到RDI和RSI寄存器。",
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: '?', RSP: '0x7ff...c8', RBP: '0x7ff...d0' }, highlightRegs: ['RDI', 'RSI'], codeLine: 8 },
                    { desc: "执行 `call add`：将返回地址压入栈，RIP跳转到add函数。", 
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: '?', RSP: '0x7ff...c0', RBP: '0x7ff...d0' }, highlightRegs: ['RSP'], codeLine: 8 },
                    { desc: "add函数序言: `push rbp`，保存main的栈底指针。一个新的栈帧开始建立。", 
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }, { name: "旧RBP (main)", type: "rbp" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: '?', RSP: '0x7ff...b8', RBP: '0x7ff...d0' }, highlightRegs: ['RSP', 'RBP'], codeLine: 1 },
                    { desc: "add函数序言: `mov rbp, rsp`，建立add函数自己的栈帧。", 
                      frames: [{ name: "add() 栈帧", color: "border-fuchsia-500", items: [{ name: "旧RBP (main)", type: "rbp" }]},{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }] }], 
                      regs: { RDI: 5, RSI: 10, RAX: '?', RSP: '0x7ff...b8', RBP: '0x7ff...b8' }, highlightRegs: ['RSP', 'RBP'], codeLine: 1 },
                    { desc: "为add的局部变量sum分配空间并计算 a + b。", 
                      frames: [{ name: "add() 栈帧", color: "border-fuchsia-500", items: [{ name: "sum = 15", type: "local" }, { name: "旧RBP (main)", type: "rbp" }]},{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: '?', RSP: '0x7ff...a8', RBP: '0x7ff...b8' }, highlightRegs: ['RSP'], codeLine: 2 },
                    { desc: "执行add函数体，计算结果放入RAX寄存器作为返回值。", 
                      frames: [{ name: "add() 栈帧", color: "border-fuchsia-500", items: [{ name: "sum = 15", type: "local" }, { name: "旧RBP (main)", type: "rbp" }]}, { name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: 15, RSP: '0x7ff...a8', RBP: '0x7ff...b8' }, highlightRegs: ['RAX'], codeLine: 3 },
                    { desc: "函数结尾: `leave`指令, 恢复调用者的栈帧，销毁add栈帧。", 
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }, { name: "返回地址 (main)", type: "ret" }] }], 
                      regs: { RDI: 5, RSI: 10, RAX: 15, RSP: '0x7ff...c0', RBP: '0x7ff...d0' }, highlightRegs: ['RSP', 'RBP'], codeLine: 4 },
                    { desc: "函数结尾: `ret`指令, 弹出返回地址到RIP，控制流回到main。", 
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 0", type: "local" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: 15, RSP: '0x7ff...c8', RBP: '0x7ff...d0' }, highlightRegs: ['RSP'], codeLine: 4 },
                    { desc: "回到main函数, 将RAX中的返回值赋给result。",
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 15", type: "local" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: 15, RSP: '0x7ff...c8', RBP: '0x7ff...d0' }, highlightRegs: [], codeLine: 8 },
                    { desc: "main函数结束。",
                      frames: [{ name: "main() 栈帧", color: "border-sky-500", items: [{ name: "result = 15", type: "local" }] }],
                      regs: { RDI: 5, RSI: 10, RAX: 15, RSP: '0x7ff...c8', RBP: '0x7ff...d0' }, highlightRegs: [], codeLine: 9 },
                ],
                colors: { local: 'bg-blue-800 border-blue-500', ret: 'bg-red-800 border-red-500', rbp: 'bg-green-800 border-green-500' },

                init() {
                    this.nextBtn.addEventListener('click', () => this.next());
                    this.prevBtn.addEventListener('click', () => this.prev());
                    this.render();
                },
                next() { if (this.currentStep < this.steps.length - 1) { this.currentStep++; this.render(); } },
                prev() { if (this.currentStep > 0) { this.currentStep--; this.render(); } },

                render() {
                    const stepData = this.steps[this.currentStep];
                    this.desc.textContent = stepData.desc;
                    
                    this.stackContainer.innerHTML = '';
                    stepData.frames.forEach(frameData => {
                        const frameEl = document.createElement('div');
                        frameEl.className = `stack-frame ${frameData.color} bg-gray-900/50`;
                        
                        const labelEl = document.createElement('div');
                        labelEl.className = `stack-frame-label ${frameData.color.replace('border', 'text')}`;
                        labelEl.textContent = frameData.name;
                        frameEl.appendChild(labelEl);

                        const itemsContainer = document.createElement('div');
                        itemsContainer.className = "space-y-1";

                        frameData.items.forEach((item, index) => {
                             const el = document.createElement('div');
                             el.className = `stack-item p-2 border-l-4 ${this.colors[item.type] || 'bg-gray-700 border-gray-500'}`;
                             el.textContent = item.name;
                             itemsContainer.appendChild(el);
                             setTimeout(() => el.classList.add('visible'), 50 * index);
                        });
                        frameEl.appendChild(itemsContainer);
                        this.stackContainer.appendChild(frameEl);
                    });


                    this.regContainer.innerHTML = '';
                    for(const regName in stepData.regs) {
                         const el = document.createElement('div');
                         el.className = `reg-item flex justify-between items-center`;
                         const valueSpan = `<span class="reg-value font-bold p-1 rounded">${stepData.regs[regName]}</span>`;
                         el.innerHTML = `<span>${regName}:</span> ${valueSpan}`;
                         this.regContainer.appendChild(el);
                         if (stepData.highlightRegs && stepData.highlightRegs.includes(regName)) {
                             setTimeout(() => el.querySelector('.reg-value').classList.add('highlight'), 50);
                         }
                         setTimeout(() => el.classList.add('visible'), 50);
                    }
                    
                    this.codeLines.forEach(line => line.classList.remove('highlight'));
                    const targetLine = document.getElementById(`anim-code-line-${stepData.codeLine}`);
                    if (targetLine) {
                        targetLine.classList.add('highlight');
                        const arrowY = targetLine.offsetTop + targetLine.offsetHeight / 2 - this.arrow.offsetHeight / 2;
                        this.arrow.style.top = `${arrowY}px`;
                        this.arrow.style.opacity = '1';
                    } else {
                        this.arrow.style.opacity = '0';
                    }
                }
            };
            stackAnim.init();

            // ret2text demo logic
            const ret2textBtn = document.getElementById('ret2text-execute-btn');
            const stackBefore = document.getElementById('stack-before-overflow');
            const stackAfter = document.getElementById('stack-after-overflow');

            function createStackItem(text, colorClass, isOverwritten = false) {
                const item = document.createElement('div');
                item.className = `demo-stack-item p-2 text-xs text-center border-l-4 ${colorClass}`;
                if (isOverwritten) {
                    item.classList.add('overwritten');
                }
                item.textContent = text;
                return item;
            }

            function initRet2textDemo() {
                stackBefore.innerHTML = '';
                stackAfter.innerHTML = '';

                // Before
                stackBefore.appendChild(createStackItem('返回地址 (main)', 'border-red-500 bg-red-900/50'));
                stackBefore.appendChild(createStackItem('保存的RBP', 'border-green-500 bg-green-900/50'));
                stackBefore.appendChild(createStackItem('buffer[64]', 'border-blue-500 bg-blue-900/50'));

                // After (initial empty state)
                stackAfter.appendChild(createStackItem('?', 'border-gray-500 bg-gray-700/50'));
                stackAfter.appendChild(createStackItem('?', 'border-gray-500 bg-gray-700/50'));
                stackAfter.appendChild(createStackItem('?', 'border-gray-500 bg-gray-700/50'));
                 
                document.querySelectorAll('.demo-stack-item').forEach((el, index) => {
                    setTimeout(() => el.classList.add('visible'), 50 * index);
                });
            }
            
            ret2textBtn.addEventListener('click', () => {
                stackAfter.innerHTML = '';
                stackAfter.appendChild(createStackItem('0x401186 (win)', 'border-red-500 bg-red-900/50', true));
                stackAfter.appendChild(createStackItem('BBBBBBBB', 'border-green-500 bg-green-900/50', true));
                stackAfter.appendChild(createStackItem('AAAAAAAAAAAAAAAA...', 'border-blue-500 bg-blue-900/50', true));
                
                document.querySelectorAll('#stack-after-overflow .demo-stack-item').forEach((el, index) => {
                    setTimeout(() => el.classList.add('visible'), 50 * index);
                });
            });

            initRet2textDemo();


            // Assembly Explorer Logic
            const cCodeContainer = document.getElementById('c-code-container');
            const asmCodeContainer = document.getElementById('asm-code-container');
            const asmTooltip = document.getElementById('asm-tooltip');
            const asmTooltipTitle = document.getElementById('asm-tooltip-title');
            const asmTooltipDesc = document.getElementById('asm-tooltip-desc');
            
            const asmTooltips = {
                'push': { title: 'push 指令', desc: '将操作数压入栈顶，并使RSP寄存器的值减小（栈向低地址增长）。' },
                'rbp': { title: 'RBP 寄存器', desc: '基址指针寄存器 (Base Pointer)，指向当前栈帧的底部，用作访问局部变量和参数的稳定基准。' },
                'mov': { title: 'mov 指令', desc: '移动/复制指令。将源操作数的值复制到目标操作数。格式：mov 目标, 源。' },
                'rsp': { title: 'RSP 寄存器', desc: '栈指针寄存器 (Stack Pointer)，始终指向栈的顶部（即最后压入的元素）。' },
                'dword_ptr': { title: 'DWORD PTR', desc: '大小指示符。表示将方括号内的地址看作一个32位（4字节）的内存区域。' },
                'rbp-14': { title: '[rbp-0x14]', desc: '内存地址。计算方式为：取RBP寄存器的值减去0x14(20)。在此上下文中，它指向为第一个参数`a`在栈上预留的存储空间。' },
                'edi': { title: 'EDI 寄存器', desc: 'RDI寄存器的低32位。根据x86-64调用约定，它用于传递第一个整型/指针参数。此处它的值是传入的参数`a` (5)。' },
                'rbp-18': { title: '[rbp-0x18]', desc: '内存地址。计算方式为：取RBP寄存器的值减去0x18(24)。在此上下文中，它指向为第二个参数`b`在栈上预留的存储空间。' },
                'esi': { title: 'ESI 寄存器', desc: 'RSI寄存器的低32位。根据x86-64调用约定，它用于传递第二个整型/指针参数。此处它的值是传入的参数`b` (10)。' },
                'edx': { title: 'EDX 寄存器', desc: 'RDX寄存器的低32位。一个通用寄存器，此处用作临时存储变量`a`的值。' },
                'eax': { title: 'EAX 寄存器', desc: 'RAX寄存器的低32位。一个通用寄存器，通常用作累加器。在此函数中，它最终将存放返回值。' },
                'add': { title: 'add 指令', desc: '加法指令。将两个操作数相加，结果存入第一个操作数。add a, b  (a = a + b)。' },
                'rbp-4': { title: '[rbp-0x4]', desc: '内存地址。计算方式为：取RBP寄存器的值减去4字节。在此上下文中，它指向局部变量`sum`在栈上的存储位置。' },
                'pop': { title: 'pop 指令', desc: '从栈顶弹出一个值到指定操作数，并使RSP寄存器的值增大。' },
                'ret': { title: 'ret 指令', desc: '返回指令。从栈顶弹出一个地址到RIP寄存器，使程序跳转到该地址继续执行。通常用于从函数调用中返回。' }
            };

            cCodeContainer.addEventListener('mouseover', (e) => {
                if (e.target.classList.contains('code-line')) {
                    const lineNum = e.target.dataset.line;
                    e.target.classList.add('highlight');
                    asmCodeContainer.querySelectorAll('.asm-line').forEach(asmLine => {
                        if(asmLine.dataset.line === lineNum) asmLine.classList.add('highlight');
                    });
                }
            });

            cCodeContainer.addEventListener('mouseout', (e) => {
                 if (e.target.classList.contains('code-line')) {
                    e.target.classList.remove('highlight');
                    asmCodeContainer.querySelectorAll('.asm-line').forEach(asmLine => asmLine.classList.remove('highlight'));
                 }
            });

            asmCodeContainer.addEventListener('mouseover', (e) => {
                if(e.target.classList.contains('asm-token')) {
                    const key = e.target.dataset.key;
                    if(asmTooltips[key]) {
                        asmTooltipTitle.textContent = asmTooltips[key].title;
                        asmTooltipDesc.textContent = asmTooltips[key].desc;
                        asmTooltip.style.display = 'block';
                    }
                }
            });
            
            asmCodeContainer.addEventListener('mouseout', () => {
                asmTooltip.style.display = 'none';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (asmTooltip.style.display === 'block') {
                    const x = e.clientX + 15;
                    const y = e.clientY + 15;
                    const tooltipRect = asmTooltip.getBoundingClientRect();
                    const bodyRect = document.body.getBoundingClientRect();
                    let newX = x;
                    let newY = y;
                    if (x + tooltipRect.width > bodyRect.width) newX = x - tooltipRect.width - 30;
                    if (y + tooltipRect.height > bodyRect.height) newY = y - tooltipRect.height - 30;
                    asmTooltip.style.left = `${newX}px`;
                    asmTooltip.style.top = `${newY}px`;
                }
            });


            // PLT/GOT Flowchart Logic
            const flowchartSteps = document.querySelectorAll('.flowchart-step');
            const nextBtn = document.getElementById('flowchart-next-btn');
            const resetBtn = document.getElementById('flowchart-reset-btn');
            let currentStep = 0;
            function updateFlowchart() {
                if (currentStep > flowchartSteps.length) currentStep = 0;
                flowchartSteps.forEach((step, index) => step.classList.toggle('active', index < currentStep));
                nextBtn.textContent = currentStep === 0 ? '开始' : '下一步';
            }
            nextBtn.addEventListener('click', () => { currentStep++; updateFlowchart(); });
            resetBtn.addEventListener('click', () => { currentStep = 0; updateFlowchart(); });
            updateFlowchart();

            // ROP Chain Logic
            const ropItems = document.querySelectorAll('.rop-item');
            const ropStack = document.getElementById('rop-stack');
            const ropFeedback = document.getElementById('rop-feedback');
            const ropResetBtn = document.getElementById('rop-reset-btn');
            let currentRopChain = [];
            const correctRopChain = ['pop rdi', '/bin/sh', 'system'];
            function renderRopStack() {
                ropStack.innerHTML = '';
                currentRopChain.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'p-2 bg-gray-700 rounded mb-2 text-center';
                    div.textContent = item;
                    ropStack.prepend(div);
                });
                checkRopChain();
            }
            function checkRopChain() {
                if (currentRopChain.length === 0) { ropFeedback.textContent = ''; return; }
                const isCorrect = JSON.stringify(currentRopChain) === JSON.stringify(correctRopChain);
                ropFeedback.textContent = isCorrect ? '✅ ROP链正确！执行 system("/bin/sh")' : '❌ ROP链不正确，请重新排序。';
                ropFeedback.className = `mt-4 text-center h-6 font-bold ${isCorrect ? 'text-green-400' : 'text-red-400'}`;
            }
            ropItems.forEach(item => {
                item.addEventListener('click', () => { currentRopChain.push(item.dataset.rop); renderRopStack(); });
            });
            ropResetBtn.addEventListener('click', () => { currentRopChain = []; renderRopStack(); });

            // Comparison Chart Logic
            const techData = {
                ret2text: { title: "ret2text", description: "最简单的技术，劫持控制流到程序中已存在的函数。如同让火车改道去一个本来就在地图上的车站。", bypass: "NX", blocked: "PIE", scores: [2, 2, 1, 1, 4] },
                ret2shellcode: { title: "ret2shellcode", description: "注入自定义代码（shellcode）并执行。如同在铁轨旁自己建了个新车站，并让火车开过去。", bypass: "无 (如果栈可执行)", blocked: "NX, ASLR", scores: [3, 5, 4, 2, 5] },
                ret2libc: { title: "ret2libc/ROP", description: "不注入代码，而是重用libc中的函数，并通过ROP链传递参数。如同利用现有铁轨和信号系统，组合出一条全新的、通往任何地方的线路。", bypass: "NX", blocked: "完全ASLR (无泄漏)", scores: [4, 5, 5, 4, 3] },
                "one-gadget": { title: "one-gadget", description: "ROP的快捷方式，直接跳转到libc中能一步到位获取shell的地址。如同发现了一张能从起点直达终点的特快车票，但有严格的检票要求。", bypass: "NX", blocked: "约束不满足, ASLR (无泄漏)", scores: [3, 5, 4, 4, 4] }
            };
            const radarCtx = document.getElementById('tech-radar-chart').getContext('2d');
            let radarChart;
            const chartOptions = {
                maintainAspectRatio: false,
                scales: { r: { angleLines: { color: 'rgba(255, 255, 255, 0.2)' }, grid: { color: 'rgba(255, 255, 255, 0.2)' }, pointLabels: { color: '#e5e7eb', font: { size: 14 } }, ticks: { color: '#d1d5db', backdropColor: 'transparent', min: 0, max: 5, stepSize: 1 } } },
                plugins: { legend: { display: false } }
            };
            function createOrUpdateChart(techKey) {
                const data = techData[techKey];
                if (radarChart) {
                    radarChart.data.datasets[0].data = data.scores;
                    radarChart.update();
                } else {
                    radarChart = new Chart(radarCtx, {
                        type: 'radar',
                        data: {
                            labels: ['实现难度', '攻击威力', '前置要求', '绕过能力', '防御健壮性'],
                            datasets: [{
                                label: data.title, data: data.scores, fill: true, backgroundColor: 'rgba(245, 158, 11, 0.2)', borderColor: 'rgb(245, 158, 11)',
                                pointBackgroundColor: 'rgb(245, 158, 11)', pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: 'rgb(245, 158, 11)'
                            }]
                        },
                        options: chartOptions
                    });
                }
                document.getElementById('tech-title').textContent = data.title;
                document.getElementById('tech-description').textContent = data.description;
                document.getElementById('tech-bypass').textContent = data.bypass;
                document.getElementById('tech-blocked').textContent = data.blocked;
                document.querySelectorAll('.tech-button').forEach(btn => btn.classList.toggle('active', btn.dataset.tech === techKey));
            }
            createOrUpdateChart('ret2text');
            document.querySelector('.tech-button').parentElement.addEventListener('click', (e) => {
                if (e.target.matches('.tech-button')) createOrUpdateChart(e.target.dataset.tech);
            });
        });
    </script>

</body>
</html>
